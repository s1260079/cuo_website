{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport handlers from './mixins/handlers';\nimport helpers from './mixins/helpers';\nimport methods from './mixins/methods';\nimport preparations from './mixins/preparations';\nimport settings from './mixins/settings';\nimport throttle from './mixins/throttle';\nimport watchers from './mixins/watchers';\nexport default {\n  name: 'Agile',\n  mixins: [handlers, helpers, methods, preparations, settings, throttle, watchers],\n  data: function data() {\n    return {\n      autoplayInterval: null,\n      autoplayRemaining: null,\n      autoplayStartTimestamp: null,\n      autoplayTimeout: null,\n      currentSlide: null,\n      dragDistance: 0,\n      dragStartX: 0,\n      dragStartY: 0,\n      isAutoplayPaused: false,\n      isMouseDown: false,\n      slides: [],\n      slidesClonedAfter: [],\n      slidesClonedBefore: [],\n      isSSR: typeof window === 'undefined',\n      transitionDelay: 0,\n      translateX: 0,\n      widthWindow: 0,\n      widthContainer: 0\n    };\n  },\n  computed: {\n    breakpoints: function breakpoints() {\n      return !this.initialSettings.responsive ? [] : this.initialSettings.responsive.map(function (item) {\n        return item.breakpoint;\n      });\n    },\n    canGoToPrev: function canGoToPrev() {\n      return this.settings.infinite || this.currentSlide > 0;\n    },\n    canGoToNext: function canGoToNext() {\n      return this.settings.infinite || this.currentSlide < this.countSlides - 1;\n    },\n    countSlides: function countSlides() {\n      return this.isSSR ? this.htmlCollectionToArray(this.$slots[\"default\"]).length : this.slides.length;\n    },\n    countSlidesAll: function countSlidesAll() {\n      return this.slidesAll.length;\n    },\n    currentBreakpoint: function currentBreakpoint() {\n      var _this = this;\n\n      var breakpoints = this.breakpoints.map(function (item) {\n        return item;\n      }).reverse();\n      return this.initialSettings.mobileFirst ? breakpoints.find(function (item) {\n        return item < _this.widthWindow;\n      }) || 0 : breakpoints.find(function (item) {\n        return item > _this.widthWindow;\n      }) || null;\n    },\n    marginX: function marginX() {\n      if (this.settings.unagile) {\n        return 0;\n      }\n\n      var marginX = this.slidesCloned ? this.countSlides * this.widthSlide : 0; // Center mode margin\n\n      if (this.settings.centerMode) {\n        marginX -= (Math.floor(this.settings.slidesToShow / 2) - +(this.settings.slidesToShow % 2 === 0)) * this.widthSlide;\n      }\n\n      return this.settings.rtl ? marginX : -1 * marginX;\n    },\n    slidesCloned: function slidesCloned() {\n      return !this.settings.unagile && !this.settings.fade && this.settings.infinite;\n    },\n    slidesAll: function slidesAll() {\n      return this.slidesCloned ? [].concat(_toConsumableArray(this.slidesClonedBefore), _toConsumableArray(this.slides), _toConsumableArray(this.slidesClonedAfter)) : this.slides;\n    },\n    widthSlide: function widthSlide() {\n      return !this.settings.unagile ? this.widthContainer / this.settings.slidesToShow : 'auto';\n    }\n  },\n  mounted: function mounted() {\n    // Windows resize listener\n    window.addEventListener('resize', this.getWidth); // Mouse and touch events\n\n    this.$refs.track.addEventListener('touchstart', this.handleMouseDown);\n    this.$refs.track.addEventListener('touchend', this.handleMouseUp);\n    this.$refs.track.addEventListener('touchmove', this.handleMouseMove);\n    this.$refs.track.addEventListener('mousedown', this.handleMouseDown);\n    this.$refs.track.addEventListener('mouseup', this.handleMouseUp);\n    this.$refs.track.addEventListener('mousemove', this.handleMouseMove); // Init\n\n    this.isSSR = false;\n    this.reload();\n  },\n  beforeDestroy: function beforeDestroy() {\n    window.removeEventListener('resize', this.getWidth);\n    this.$refs.track.removeEventListener('touchstart', this.handleMouseDown);\n    this.$refs.track.removeEventListener('touchend', this.handleMouseUp);\n    this.$refs.track.removeEventListener('touchmove', this.handleMouseMove);\n    this.$refs.track.removeEventListener('mousedown', this.handleMouseDown);\n    this.$refs.track.removeEventListener('mouseup', this.handleMouseUp);\n    this.$refs.track.removeEventListener('mousemove', this.handleMouseMove);\n    this.disableAutoPlay();\n  },\n  methods: {\n    // Return current breakpoint\n    getCurrentBreakpoint: function getCurrentBreakpoint() {\n      return this.currentBreakpoint;\n    },\n    // Return settings for current breakpoint\n    getCurrentSettings: function getCurrentSettings() {\n      return this.settings;\n    },\n    // Return current slide index\n    getCurrentSlide: function getCurrentSlide() {\n      return this.currentSlide;\n    },\n    // Return initial settings\n    getInitialSettings: function getInitialSettings() {\n      return this.initialSettings;\n    },\n    // Go to slide\n    goTo: function goTo(n) {\n      var _this2 = this;\n\n      var transition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var asNav = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      // Break goTo() if unagile is active\n      if (this.settings.unagile) {\n        return false;\n      }\n\n      if (!asNav) {\n        this.settings.asNavFor.forEach(function (carousel) {\n          if (carousel) {\n            carousel.goTo(n, transition, true);\n          }\n        });\n      }\n\n      var slideNextReal = n;\n\n      if (transition) {\n        if (this.settings.infinite && n < 0) {\n          slideNextReal = this.countSlides - 1;\n        } else if (n >= this.countSlides) {\n          slideNextReal = 0;\n        }\n\n        this.$emit('before-change', {\n          currentSlide: this.currentSlide,\n          nextSlide: slideNextReal\n        });\n        this.currentSlide = slideNextReal;\n\n        if (n !== slideNextReal) {\n          setTimeout(function () {\n            _this2.goTo(slideNextReal, false);\n          }, this.settings.speed);\n        }\n      }\n\n      var translateX = !this.settings.fade ? n * this.widthSlide * this.settings.slidesToScroll : 0;\n      this.transitionDelay = transition ? this.speed : 0;\n\n      if (this.infinite || this.currentSlide + this.slidesToShow <= this.countSlides) {\n        this.translateX = this.settings.rtl ? translateX : -1 * translateX;\n      }\n    },\n    // Go to next slide\n    goToNext: function goToNext() {\n      if (this.canGoToNext) {\n        this.goTo(this.currentSlide + 1);\n      }\n    },\n    // Go to previous slide\n    goToPrev: function goToPrev() {\n      if (this.canGoToPrev) {\n        this.goTo(this.currentSlide - 1);\n      }\n    },\n    // Reload carousel\n    reload: function reload() {\n      this.getWidth();\n      this.prepareSlides();\n      this.prepareCarousel();\n      this.toggleFade();\n      this.toggleAutoPlay();\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}