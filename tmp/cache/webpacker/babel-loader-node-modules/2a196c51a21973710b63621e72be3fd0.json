{"ast":null,"code":"'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar path = require('path');\n\nvar os = require('os');\n\nvar fs = require('graceful-fs');\n\nvar makeDir = require('make-dir');\n\nvar xdgBasedir = require('xdg-basedir');\n\nvar writeFileAtomic = require('write-file-atomic');\n\nvar dotProp = require('dot-prop');\n\nvar uniqueString = require('unique-string');\n\nvar configDirectory = xdgBasedir.config || path.join(os.tmpdir(), uniqueString());\nvar permissionError = 'You don\\'t have access to this file.';\nvar makeDirOptions = {\n  mode: 448\n};\nvar writeFileOptions = {\n  mode: 384\n};\n\nvar Configstore = /*#__PURE__*/function () {\n  function Configstore(id, defaults) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, Configstore);\n\n    var pathPrefix = options.globalConfigPath ? path.join(id, 'config.json') : path.join('configstore', \"\".concat(id, \".json\"));\n    this.path = options.configPath || path.join(configDirectory, pathPrefix);\n\n    if (defaults) {\n      this.all = _objectSpread(_objectSpread({}, defaults), this.all);\n    }\n  }\n\n  _createClass(Configstore, [{\n    key: \"all\",\n    get: function get() {\n      try {\n        return JSON.parse(fs.readFileSync(this.path, 'utf8'));\n      } catch (error) {\n        // Create directory if it doesn't exist\n        if (error.code === 'ENOENT') {\n          return {};\n        } // Improve the message of permission errors\n\n\n        if (error.code === 'EACCES') {\n          error.message = \"\".concat(error.message, \"\\n\").concat(permissionError, \"\\n\");\n        } // Empty the file if it encounters invalid JSON\n\n\n        if (error.name === 'SyntaxError') {\n          writeFileAtomic.sync(this.path, '', writeFileOptions);\n          return {};\n        }\n\n        throw error;\n      }\n    },\n    set: function set(value) {\n      try {\n        // Make sure the folder exists as it could have been deleted in the meantime\n        makeDir.sync(path.dirname(this.path), makeDirOptions);\n        writeFileAtomic.sync(this.path, JSON.stringify(value, undefined, '\\t'), writeFileOptions);\n      } catch (error) {\n        // Improve the message of permission errors\n        if (error.code === 'EACCES') {\n          error.message = \"\".concat(error.message, \"\\n\").concat(permissionError, \"\\n\");\n        }\n\n        throw error;\n      }\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return Object.keys(this.all || {}).length;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      return dotProp.get(this.all, key);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var config = this.all;\n\n      if (arguments.length === 1) {\n        for (var _i = 0, _Object$keys = Object.keys(key); _i < _Object$keys.length; _i++) {\n          var k = _Object$keys[_i];\n          dotProp.set(config, k, key[k]);\n        }\n      } else {\n        dotProp.set(config, key, value);\n      }\n\n      this.all = config;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return dotProp.has(this.all, key);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var config = this.all;\n      dotProp[\"delete\"](config, key);\n      this.all = config;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.all = {};\n    }\n  }]);\n\n  return Configstore;\n}();\n\nmodule.exports = Configstore;","map":null,"metadata":{},"sourceType":"module"}