{"ast":null,"code":"\"use strict\"; // Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * @module common/service-object\n */\n\nvar promisify_1 = require(\"@google-cloud/promisify\");\n\nvar arrify = require(\"arrify\");\n\nvar events_1 = require(\"events\");\n\nvar extend = require(\"extend\");\n\nvar util_1 = require(\"./util\");\n/**\n * ServiceObject is a base class, meant to be inherited from by a \"service\n * object,\" like a BigQuery dataset or Storage bucket.\n *\n * Most of the time, these objects share common functionality; they can be\n * created or deleted, and you can get or set their metadata.\n *\n * By inheriting from this class, a service object will be extended with these\n * shared behaviors. Note that any method can be overridden when the service\n * object requires specific behavior.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nvar ServiceObject = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(ServiceObject, _events_1$EventEmitte);\n\n  var _super = _createSuper(ServiceObject);\n\n  /*\n   * @constructor\n   * @alias module:common/service-object\n   *\n   * @private\n   *\n   * @param {object} config - Configuration object.\n   * @param {string} config.baseUrl - The base URL to make API requests to.\n   * @param {string} config.createMethod - The method which creates this object.\n   * @param {string=} config.id - The identifier of the object. For example, the\n   *     name of a Storage bucket or Pub/Sub topic.\n   * @param {object=} config.methods - A map of each method name that should be inherited.\n   * @param {object} config.methods[].reqOpts - Default request options for this\n   *     particular method. A common use case is when `setMetadata` requires a\n   *     `PUT` method to override the default `PATCH`.\n   * @param {object} config.parent - The parent service instance. For example, an\n   *     instance of Storage if the object is Bucket.\n   */\n  function ServiceObject(config) {\n    var _this;\n\n    _classCallCheck(this, ServiceObject);\n\n    _this = _super.call(this);\n    _this.metadata = {};\n    _this.baseUrl = config.baseUrl;\n    _this.parent = config.parent; // Parent class.\n\n    _this.id = config.id; // Name or ID (e.g. dataset ID, bucket name, etc).\n\n    _this.createMethod = config.createMethod;\n    _this.methods = config.methods || {};\n    _this.interceptors = [];\n    _this.pollIntervalMs = config.pollIntervalMs;\n\n    if (config.methods) {\n      // This filters the ServiceObject instance (e.g. a \"File\") to only have\n      // the configured methods. We make a couple of exceptions for core-\n      // functionality (\"request()\" and \"getRequestInterceptors()\")\n      Object.getOwnPropertyNames(ServiceObject.prototype).filter(function (methodName) {\n        return (// All ServiceObjects need `request` and `getRequestInterceptors`.\n          // clang-format off\n          !/^request/.test(methodName) && !/^getRequestInterceptors/.test(methodName) && // clang-format on\n          // The ServiceObject didn't redefine the method.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          _this[methodName] === // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ServiceObject.prototype[methodName] && // This method isn't wanted.\n          !config.methods[methodName]\n        );\n      }).forEach(function (methodName) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        _this[methodName] = undefined;\n      });\n    }\n\n    return _this;\n  }\n\n  _createClass(ServiceObject, [{\n    key: \"create\",\n    value: function create(optionsOrCallback, callback) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      var self = this;\n      var args = [this.id];\n\n      if (typeof optionsOrCallback === 'function') {\n        callback = optionsOrCallback;\n      }\n\n      if (_typeof(optionsOrCallback) === 'object') {\n        args.push(optionsOrCallback);\n      } // Wrap the callback to return *this* instance of the object, not the\n      // newly-created one.\n      // tslint: disable-next-line no-any\n\n\n      function onCreate() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var err = args[0],\n            instance = args[1];\n\n        if (!err) {\n          self.metadata = instance.metadata;\n          args[1] = self; // replace the created `instance` with this one.\n        }\n\n        callback.apply(void 0, args);\n      }\n\n      args.push(onCreate); // eslint-disable-next-line prefer-spread\n\n      this.createMethod.apply(null, args);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(optionsOrCallback, cb) {\n      var _util_1$util$maybeOpt = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb),\n          _util_1$util$maybeOpt2 = _slicedToArray(_util_1$util$maybeOpt, 2),\n          options = _util_1$util$maybeOpt2[0],\n          callback = _util_1$util$maybeOpt2[1];\n\n      var ignoreNotFound = options.ignoreNotFound;\n      delete options.ignoreNotFound;\n      var methodConfig = _typeof(this.methods[\"delete\"]) === 'object' && this.methods[\"delete\"] || {};\n      var reqOpts = extend(true, {\n        method: 'DELETE',\n        uri: ''\n      }, methodConfig.reqOpts, {\n        qs: options\n      }); // The `request` method may have been overridden to hold any special\n      // behavior. Ensure we call the original `request` method.\n\n      ServiceObject.prototype.request.call(this, reqOpts, function (err) {\n        if (err) {\n          if (err.code === 404 && ignoreNotFound) {\n            err = null;\n          }\n        }\n\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        callback.apply(void 0, [err].concat(args));\n      });\n    }\n  }, {\n    key: \"exists\",\n    value: function exists(optionsOrCallback, cb) {\n      var _util_1$util$maybeOpt3 = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb),\n          _util_1$util$maybeOpt4 = _slicedToArray(_util_1$util$maybeOpt3, 2),\n          options = _util_1$util$maybeOpt4[0],\n          callback = _util_1$util$maybeOpt4[1];\n\n      this.get(options, function (err) {\n        if (err) {\n          if (err.code === 404) {\n            callback(null, false);\n          } else {\n            callback(err);\n          }\n\n          return;\n        }\n\n        callback(null, true);\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(optionsOrCallback, cb) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      var self = this;\n\n      var _util_1$util$maybeOpt5 = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb),\n          _util_1$util$maybeOpt6 = _slicedToArray(_util_1$util$maybeOpt5, 2),\n          opts = _util_1$util$maybeOpt6[0],\n          callback = _util_1$util$maybeOpt6[1];\n\n      var options = Object.assign({}, opts);\n      var autoCreate = options.autoCreate && typeof this.create === 'function';\n      delete options.autoCreate;\n\n      function onCreate(err, instance, apiResponse) {\n        if (err) {\n          if (err.code === 409) {\n            self.get(options, callback);\n            return;\n          }\n\n          callback(err, null, apiResponse);\n          return;\n        }\n\n        callback(null, instance, apiResponse);\n      }\n\n      this.getMetadata(options, function (err, metadata) {\n        if (err) {\n          if (err.code === 404 && autoCreate) {\n            var args = [];\n\n            if (Object.keys(options).length > 0) {\n              args.push(options);\n            }\n\n            args.push(onCreate);\n            self.create.apply(self, args);\n            return;\n          }\n\n          callback(err, null, metadata);\n          return;\n        }\n\n        callback(null, self, metadata);\n      });\n    }\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata(optionsOrCallback, cb) {\n      var _this2 = this;\n\n      var _util_1$util$maybeOpt7 = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb),\n          _util_1$util$maybeOpt8 = _slicedToArray(_util_1$util$maybeOpt7, 2),\n          options = _util_1$util$maybeOpt8[0],\n          callback = _util_1$util$maybeOpt8[1];\n\n      var methodConfig = _typeof(this.methods.getMetadata) === 'object' && this.methods.getMetadata || {};\n      var reqOpts = extend(true, {\n        uri: ''\n      }, methodConfig.reqOpts, {\n        qs: options\n      }); // The `request` method may have been overridden to hold any special\n      // behavior. Ensure we call the original `request` method.\n\n      ServiceObject.prototype.request.call(this, reqOpts, function (err, body, res) {\n        _this2.metadata = body;\n        callback(err, _this2.metadata, res);\n      });\n    }\n    /**\n     * Return the user's custom request interceptors.\n     */\n\n  }, {\n    key: \"getRequestInterceptors\",\n    value: function getRequestInterceptors() {\n      // Interceptors should be returned in the order they were assigned.\n      var localInterceptors = this.interceptors.filter(function (interceptor) {\n        return typeof interceptor.request === 'function';\n      }).map(function (interceptor) {\n        return interceptor.request;\n      });\n      return this.parent.getRequestInterceptors().concat(localInterceptors);\n    }\n  }, {\n    key: \"setMetadata\",\n    value: function setMetadata(metadata, optionsOrCallback, cb) {\n      var _this3 = this;\n\n      var _util_1$util$maybeOpt9 = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb),\n          _util_1$util$maybeOpt10 = _slicedToArray(_util_1$util$maybeOpt9, 2),\n          options = _util_1$util$maybeOpt10[0],\n          callback = _util_1$util$maybeOpt10[1];\n\n      var methodConfig = _typeof(this.methods.setMetadata) === 'object' && this.methods.setMetadata || {};\n      var reqOpts = extend(true, {}, {\n        method: 'PATCH',\n        uri: ''\n      }, methodConfig.reqOpts, {\n        json: metadata,\n        qs: options\n      }); // The `request` method may have been overridden to hold any special\n      // behavior. Ensure we call the original `request` method.\n\n      ServiceObject.prototype.request.call(this, reqOpts, function (err, body, res) {\n        _this3.metadata = body;\n        callback(err, _this3.metadata, res);\n      });\n    }\n  }, {\n    key: \"request_\",\n    value: function request_(reqOpts, callback) {\n      reqOpts = extend(true, {}, reqOpts);\n      var isAbsoluteUrl = reqOpts.uri.indexOf('http') === 0;\n      var uriComponents = [this.baseUrl, this.id || '', reqOpts.uri];\n\n      if (isAbsoluteUrl) {\n        uriComponents.splice(0, uriComponents.indexOf(reqOpts.uri));\n      }\n\n      reqOpts.uri = uriComponents.filter(function (x) {\n        return x.trim();\n      }) // Limit to non-empty strings.\n      .map(function (uriComponent) {\n        var trimSlashesRegex = /^\\/*|\\/*$/g;\n        return uriComponent.replace(trimSlashesRegex, '');\n      }).join('/');\n      var childInterceptors = arrify(reqOpts.interceptors_);\n      var localInterceptors = [].slice.call(this.interceptors);\n      reqOpts.interceptors_ = childInterceptors.concat(localInterceptors);\n\n      if (reqOpts.shouldReturnStream) {\n        return this.parent.requestStream(reqOpts);\n      }\n\n      this.parent.request(reqOpts, callback);\n    }\n  }, {\n    key: \"request\",\n    value: function request(reqOpts, callback) {\n      this.request_(reqOpts, callback);\n    }\n    /**\n     * Make an authenticated API request.\n     *\n     * @param {object} reqOpts - Request options that are passed to `request`.\n     * @param {string} reqOpts.uri - A URI relative to the baseUrl.\n     */\n\n  }, {\n    key: \"requestStream\",\n    value: function requestStream(reqOpts) {\n      var opts = extend(true, reqOpts, {\n        shouldReturnStream: true\n      });\n      return this.request_(opts);\n    }\n  }]);\n\n  return ServiceObject;\n}(events_1.EventEmitter);\n\nexports.ServiceObject = ServiceObject;\npromisify_1.promisifyAll(ServiceObject, {\n  exclude: ['getRequestInterceptors']\n});","map":null,"metadata":{},"sourceType":"module"}